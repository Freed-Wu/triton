# NVWSOps<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### `nvws.aref.create` (triton::nvws::ArefCreateOp)

_Create an asynchronous reference._

Syntax:

```
operation ::= `nvws.aref.create` $operands attr-dict `:` type($result)
```

Create an asynchronous reference.

Takes as inputs a variadic number of operands, and returns an ARef.
The inputs can be of any type, but if the numBatchAxes attribute is
set on the result type, the inputs are expected to be array-like
(i.e., Tensor, MemDesc, etc) and have matching values for the first
numBatchAxes of the shapes.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | variadic of any type |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | Asynchronous Reference |


### `nvws.aref.get` (triton::nvws::ArefGetOp)

_Get value(s) from an asynchronous reference_

Get values from the asynchronous reference for reading.

If indexes is empty, the op will return the entire underlying value(s).
If the indexes is size 1, the op will ensure that the underlying
value is Tensor-Like (i.e, has a shape parameter) with rank at least 1,
and index into the first dimension in a circular fashion, by wrapping the
index around the boundaries of that dimension.
Similarly, if indexes is size 2, the op will index into the first 2 dimensions
etc.

These values are passed as arguments to the region.
At the start of the region, the values are guaranteed to be “full”,
and operations are free to read from them. When the compute in the region
completes, the buffers have been read from, and the aref is marked as “empty”
so that a producer group can write to the aref.


#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | Asynchronous Reference |
| `indexes` | variadic of integer or ranked tensor of integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type |


### `nvws.aref.put` (triton::nvws::ArefPutOp)

_Put value(s) into an asynchronous reference_

Get values from the asynchronous reference for writing.

If indexes is empty, the op will return the entire underlying value(s).
If the indexes is size 1, the op will ensure that the underlying
value is Tensor-Like (i.e, has a shape parameter) with rank at least 1,
and index into the first dimension in a circular fashion, by wrapping the
index around the boundaries of that dimension.
Similarly, if indexes is size 2, the op will index into the first 2 dimensions
etc.

These values are passed as arguments to the region.
At the start of the region, the values are guaranteed to be “empty”,
and operations are free to write to them. When the compute in the region
completes, the buffers have been written to, and the aref is marked as “full”
so that a consumer can read from them.

If the Aref contains in-register types (i.e., not ttg.MemDesc), the region should
return the updated values. This represents a semantic copy at the aref level,
but should be optimized away during lowering.


Traits: `SameVariadicOperandSize`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | Asynchronous Reference |
| `indexes` | variadic of integer or ranked tensor of integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type |


### `nvws.aref.return` (triton::nvws::ArefReturnOp)

_Terminator for aref_put/get operator_

Syntax:

```
operation ::= `nvws.aref.return` attr-dict ($srcs^ `:` type($srcs))?
```

Traits: `AlwaysSpeculatableImplTrait`, `ReturnLike`, `Terminator`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `srcs` | variadic of any type |


### `nvws.warp_group` (triton::nvws::WarpGroupOp)

_Container Op for Warp Specialization_

Higher level container for Warp Specialization Analysis.

Contains a variadic number warp groups, with
the number of warps in each group, plus a region to hold the
computation for that warp group.

Regions are not Isolated from Above to aid in analysis,
and take inputs purely by reference.

nvws.warp_group should be lowered to ttg.warp_specialize
before execution.

Traits: `RecursiveMemoryEffects`, `RecursivelySpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>numWarps</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr>
</table>


### `nvws.warp_group.return` (triton::nvws::WarpGroupReturnOp)

_Terminator for a warp group region_

Syntax:

```
operation ::= `nvws.warp_group.return` attr-dict
```

Warp groups are expected to return values via referential modification
of their inputs. Thus, the warp_group.return op takes no values to
return from the warp group.

Traits: `AlwaysSpeculatableImplTrait`, `HasParent<WarpGroupOp>`, `Terminator`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`


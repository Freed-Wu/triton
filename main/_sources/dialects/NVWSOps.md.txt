# NVWSOps<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### `nvws.aref.create` (triton::nvws::ArefCreateOp)

_Create an asynchronous reference._

Syntax:

```
operation ::= `nvws.aref.create` $operands attr-dict `:` type($result)
```

Create an asynchronous reference.

Takes as inputs a variadic number of operands, and returns an ARef.
The inputs can be of any type, but if the numBatchAxes attribute is
set on the result type, the inputs are expected to be array-like
(i.e., Tensor, MemDesc, etc) and have matching values for the first
numBatchAxes of the shapes.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | variadic of any type |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | Asynchronous Reference |


### `nvws.aref.get` (triton::nvws::ArefGetOp)

_Get value(s) from an asynchronous reference_

Get values from the asynchronous reference for reading.

If indexes is empty, the op will return the entire underlying value(s).
If the indexes is size 1, the op will ensure that the underlying
value is Tensor-Like (i.e, has a shape parameter) with rank at least 1,
and index into the first dimension.
Similarly, if indexes is size 2, the op will index into the first 2 dimensions
etc.

These values are passed as arguments to the region.
At the start of the region, the values are guaranteed to be “full”,
and operations are free to read from them. When the compute in the region
completes, the buffers have been read from, and the aref is marked as “empty”
so that a producer group can write to the aref.


#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | Asynchronous Reference |
| `indexes` | variadic of integer or ranked tensor of integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type |


### `nvws.aref.put` (triton::nvws::ArefPutOp)

_Put value(s) into an asynchronous reference_

Get values from the asynchronous reference for writing.

If indexes is empty, the op will return the entire underlying value(s).
If the indexes is size 1, the op will ensure that the underlying
value is Tensor-Like (i.e, has a shape parameter) with rank at least 1,
and index into the first dimension.
Similarly, if indexes is size 2, the op will index into the first 2 dimensions
etc.

These values are passed as arguments to the region.
At the start of the region, the values are guaranteed to be “empty”,
and operations are free to write to them. When the compute in the region
completes, the buffers have been written to, and the aref is marked as “full”
so that a consumer can read from them.

If the Aref contains in-register types (i.e., not ttg.MemDesc), the region should
return the updated values. This represents a semantic copy at the aref level,
but should be optimized away during lowering.


Traits: `SameVariadicOperandSize`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operand` | Asynchronous Reference |
| `indexes` | variadic of integer or ranked tensor of integer values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | variadic of any type |


### `nvws.aref.return` (triton::nvws::ArefReturnOp)

_Terminator for aref_put/get operator_

Syntax:

```
operation ::= `nvws.aref.return` attr-dict ($srcs^ `:` type($srcs))?
```

Traits: `AlwaysSpeculatableImplTrait`, `ReturnLike`, `Terminator`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`, `RegionBranchTerminatorOpInterface`

Effects: `MemoryEffects::Effect{}`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `srcs` | variadic of any type |

